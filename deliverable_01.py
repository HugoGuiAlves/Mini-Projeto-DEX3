# -*- coding: utf-8 -*-
"""Cópia de Deliverable_01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11mKiSjsDXNunVC9beej8s21QPPzXEjnX

# Deliverable 01

Trabalho de consultoria para Roof Imóveis.

A empresa deseja investir em imóveis no exterior, e está buscando opções no condado de King County.

Condado de King está localizado no estado de Whashington, fundado em 1852, possui mais de 2,2 milhões de habitantes, cuja sede e cidade mais populosa é Seatle.

Objetivos:

- Informar 5 imóveis para investir e o motivo;
- Informar 5 imóveis para não investir;

##Obtenção de dados

Fontes:


Dataset venda de imóveis:
https://geodacenter.github.io/data-and-lab/KingCounty-HouseSales2015/

Dataset ZipCode:
https://gis-kingcounty.opendata.arcgis.com/datasets/zipcodes-for-king-county-and-surrounding-area-shorelines-zipcode-shore-area/explore?location=47.509950%2C-121.477600%2C8.52
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Importando Bibliotecas"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats

"""#Importando Dataframes"""

df = pd.read_csv('/content/drive/MyDrive/DEX03/Deliverable 01/DATA/kc_house_data.csv')

df_zipcode = pd.read_csv('/content/drive/MyDrive/DEX03/Deliverable 01/DATA/Zipcodes_for_King_County_and_Surrounding_Area_(Shorelines)___zipcode_shore_area.csv')

"""#Análise dos dados

##Verificando os DF's
"""

df.head()

df_zipcode.head()

df.info()

len(df['id'].unique())

"""Há casas que foram vendidas mais de uma vez no período"""

df_zipcode.info()

"""Só precisaremos das colunas ZIPCODE e PREFERRED_CITY"""

df_zipcode.drop(['OBJECTID', 'ZIP','COUNTY','ZIP_TYPE','COUNTY_NAME','Shape_Length','Shape_Area'], axis=1, inplace=True)

df_zipcode.rename(columns={'ZIPCODE': 'zipcode', 'PREFERRED_CITY': 'cidade'}, inplace=True)

df_zipcode

"""Remover os zipcodes duplicados"""

dfz = df_zipcode.drop_duplicates(subset=['zipcode']).reset_index(drop=True)

dfz

"""Cuidando da coluna de data, para que fique no formato correto e possamos separar as colunas em DIA, MES e ANO"""

# Transformar coluna 'date' em Datetype
df['date'] = pd.to_datetime(df['date'])

# Criando a coluna Ano
df['ano'] = pd.DatetimeIndex(df['date']).year
# Criando a coluna Mês
df['mes'] = pd.DatetimeIndex(df['date']).month
# Criando a coluna Dia
df['dia'] = pd.DatetimeIndex(df['date']).day

df.info()

dfz.info()

"""##Unindo os DF's"""

df2 = pd.merge(df,dfz, on='zipcode', how='left')

df2.info()

"""Criando colunas do preço por pés ao quadrado"""

# preço por pés ao quadrado - área habitável 
df2['preco por ft² habitavel'] = df2['price'] / df2['sqft_living']
# preço por pés ao quadrado - área lote 
df2['preco por ft² lote'] = df2['price'] / df2['sqft_lot']

"""Podemos remover a coluna:

- A coluna DATE já foi desmembrada em nas colunas DIA, MES e ANO
"""

df2.drop('date', axis=1, inplace=True)

df2.info()

"""##Definindo funções de gráficos"""

def histograma(coluna, bins):
  fig = plt.figure()
  plt.hist(df2[coluna],bins=bins)
  plt.title(coluna, loc = 'left')
  plt.xlabel(coluna)
  plt.ylabel('Frequência')
  plt.show()

"""verificando o gráfico de frequência de cada atributo"""

for item in df2.columns:
  histograma(item, 20)

len(df2['id'].unique())

len(df2['id'])

# Criando DF com valores duplicados na coluna ID
dfdup = df2[df2['id'].duplicated(keep=False)]

# Ordenando o DF com valores duplicados na coluna ID
dfdup.sort_values(by=['id','ano','mes','dia'], ascending=False)

display(dfdup)

# Verificando a quantidade de vezes que um imóvel foi vendido
dfdup['id'].value_counts()

dfdup[dfdup['id'] == 795000620 ]

"""podemos remover o index 17603 para verificar o lucro total do período"""

dfdup = dfdup.drop(17603)

dfdup.info()

# Criando DF de lucro
lucro = dfdup[['id','price']].groupby(by=['id']).diff()

# Renomeando a coluna 'price' para 'lucro'
lucro.rename(columns = {'price': 'lucro/prejuízo'}, inplace = True)

lucro

# Juntando os DF, como eles estão na mesma ordem podemos juntar direto
dfdup = dfdup.join(lucro)

display(dfdup)

# Criando a coluna de lucro em percentual
dfdup['lucro/prejuízo em %'] = dfdup['lucro/prejuízo'] / (dfdup['price']-dfdup['lucro/prejuízo']) * 100

dfdup = dfdup.sort_values(by=['lucro/prejuízo em %'], ascending=False)

dfdup.head(15)

# Retirando as linhas com valores NaN
dfdup = dfdup.dropna()

dfdup

